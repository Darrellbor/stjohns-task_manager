import { SerializedError } from '@reduxjs/toolkit';

/**
 * @see https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usequery
 */
export type TUseQueryResult<T> = {
  /* Arguments passed to the query */
  originalArgs?: unknown;
  /* The latest returned result regardless of hook arg, if present */
  data?: T;
  /* The latest returned result for the current hook arg, if present */
  currentData?: T;
  /* Error result if present */
  error?: SerializedError;
  /* A string generated by RTK Query */
  requestId?: string;
  /* The name of the given endpoint for the query */
  endpointName?: string;
  /* Timestamp for when the query was initiated */
  startedTimeStamp?: number;
  /* Timestamp for when the query was completed */
  fulfilledTimeStamp?: number;

  /* Query has not started yet. */
  isUninitialized: boolean;
  /* Query is currently loading for the first time. No data yet. */
  isLoading: boolean;
  /* Query is currently fetching, but might have data from an earlier request. */
  isFetching: boolean;
  /* Query has data from a successful load. */
  isSuccess: boolean;
  /* Query is currently in an "error" state. */
  isError: boolean;
  /* A function to force refetch the query */
  refetch: () => void;
};

/**
 * @see https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usequery
 */
export type TUseQueryOptions = {
  pollingInterval?: number;
  refetchOnFocus?: boolean;
  refetchOnMountOrArgChange?: boolean | number;
  refetchOnReconnect?: boolean;
  skip?: boolean;
};

export enum EMockType {
  Empty,
  Error,
  Loading,
  Success,
}

export type TMockApi<T> =
  | { type: EMockType.Empty }
  | { type: EMockType.Loading }
  | { type: EMockType.Success; data: T }
  | { type: EMockType.Error; error: SerializedError };

/**
 * mock API response
 * @see https://redux-toolkit.js.org/rtk-query/usage/queries#frequently-used-query-hook-return-values
 * @returns
 */
export const useMockApi = <T>(
  mock: TMockApi<T>,
  opts?: TUseQueryOptions
): TUseQueryResult<T> => {
  if (opts?.skip) {
    return {
      isError: false,
      isFetching: false,
      isLoading: false,
      isSuccess: false,
      isUninitialized: true,
      refetch: () => {
        return;
      },
    };
  }
  switch (mock.type) {
    case EMockType.Empty:
      return {
        data: undefined,
        error: undefined,
        isError: false,
        isFetching: false,
        isLoading: false,
        isSuccess: true,
        isUninitialized: false,
        refetch: () => {
          return;
        },
      };
    case EMockType.Loading:
      return {
        data: undefined,
        error: undefined,
        isError: false,
        isFetching: false,
        isLoading: true,
        isSuccess: false,
        isUninitialized: false,
        refetch: () => {
          return;
        },
      };
    case EMockType.Success:
      return {
        data: mock.data,
        error: undefined,
        isError: false,
        isFetching: false,
        isLoading: false,
        isSuccess: true,
        isUninitialized: false,
        refetch: () => {
          return;
        },
      };
    case EMockType.Error:
      return {
        data: undefined,
        error: mock.error,
        isError: true,
        isFetching: false,
        isLoading: false,
        isSuccess: false,
        isUninitialized: false,
        refetch: () => {
          return;
        },
      };
  }
};
